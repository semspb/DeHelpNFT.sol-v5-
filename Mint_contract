// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

interface IDeHelpNFT {
    function mint(address to, uint256 level) external returns (uint256);
}

interface IReferralRegistry {
    function bindSponsor(uint256 tokenId, uint256 sponsorTokenId) external;
}

interface IDistributionController {
    function split(uint256 amount) external view returns (
        uint256 referralAmount,
        uint256 poolAmount,
        uint256 reserveAmount
    );
}

interface IRevenuePool {
    function addShares(uint256 tokenId, uint256 shares) external;
    function deposit(uint256 amount) external;
}

interface IReferralRewards {
    function distributeRewards(uint256 tokenId, uint256 amount) external;
}

/**
 * @title SaleMintController
 * @notice Контроллер минта NFT с интеграцией реферальной системы
 * Распределение средств:
 * - 92% на реферальные награды (7 уровней)
 * - 7% в партнерский пул
 * - 1% в резерв/казну
 */
contract SaleMintController is AccessControl, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant CONFIG_ROLE = keccak256("CONFIG_ROLE");

    IERC20 public usdt;
    IDeHelpNFT public nft;
    IReferralRegistry public referralRegistry;
    IDistributionController public distController;
    IRevenuePool public revenuePool;
    IReferralRewards public referralRewards;
    address public treasury;

    uint256 public basePrice;
    uint256 public defaultSharesPerNFT = 1;
    
    // Partner system constants from Marketing
    uint256 public constant PARTNER_MIN_MINTS = 10;
    uint256 public constant MAX_LEVELS_TO_CLIMB = 10;
    
    // Tracking user mints for partner status
    mapping(address => uint256) public userMintCount;

    event Minted(
        address indexed buyer,
        uint256 tokenId,
        uint256 level,
        uint256 price
    );
    
    event PartnerStatusAchieved(
        address indexed user,
        uint256 mintCount
    );
    
    event TreasuryFunded(address indexed treasury, uint256 amount);

    constructor(
        address admin,
        address usdtAddress,
        address nftAddress,
        address referralAddress,
        address distAddress,
        address revenueAddress,
        address referralRewardsAddress,
        address treasuryAddress,
        uint256 _basePrice
    ) {
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(MINTER_ROLE, admin);
        _grantRole(CONFIG_ROLE, admin);

        usdt = IERC20(usdtAddress);
        nft = IDeHelpNFT(nftAddress);
        referralRegistry = IReferralRegistry(referralAddress);
        distController = IDistributionController(distAddress);
        revenuePool = IRevenuePool(revenueAddress);
        referralRewards = IReferralRewards(referralRewardsAddress);
        treasury = treasuryAddress;

        basePrice = _basePrice;
    }

    // ------------------------
    // Mint
    // ------------------------
    /**
     * @notice Минт NFT с автоматическим распределением средств
     * @param level Уровень NFT
     * @param sponsorTokenId ID спонсорского NFT (0 если нет спонсора)
     */
    function mint(
        uint256 level,
        uint256 sponsorTokenId
    ) external whenNotPaused nonReentrant {
        uint256 totalPrice = basePrice;

        // Перевод USDT
        usdt.safeTransferFrom(msg.sender, address(this), totalPrice);

        // 1️⃣ Mint NFT
        uint256 tokenId = nft.mint(msg.sender, level);
        
        // Track mint count for partner status
        userMintCount[msg.sender]++;
        if (userMintCount[msg.sender] == PARTNER_MIN_MINTS) {
            emit PartnerStatusAchieved(msg.sender, PARTNER_MIN_MINTS);
        }

        // 2️⃣ Bind sponsor (если есть)
        if (sponsorTokenId != 0) {
            referralRegistry.bindSponsor(tokenId, sponsorTokenId);
        }

        // 3️⃣ Split funds according to distribution
        (uint256 referralAmt, uint256 poolAmt, uint256 reserveAmt) =
            distController.split(totalPrice);

        // 4️⃣ Distribute referral rewards (92% across 7 levels)
        if (referralAmt > 0) {
            usdt.approve(address(referralRewards), referralAmt);
            referralRewards.distributeRewards(tokenId, referralAmt);
        }

        // 5️⃣ Add to revenue pool (7%)
        if (poolAmt > 0) {
            usdt.safeTransfer(address(revenuePool), poolAmt);
            revenuePool.deposit(poolAmt);
            revenuePool.addShares(tokenId, defaultSharesPerNFT);
        }

        // 6️⃣ Send reserve to treasury (1%)
        if (reserveAmt > 0) {
            usdt.safeTransfer(treasury, reserveAmt);
            emit TreasuryFunded(treasury, reserveAmt);
        }

        emit Minted(msg.sender, tokenId, level, totalPrice);
    }

    // ------------------------
    // Views
    // ------------------------
    
    /**
     * @notice Проверить, является ли пользователь партнером
     */
    function isPartner(address user) external view returns (bool) {
        return userMintCount[user] >= PARTNER_MIN_MINTS;
    }
    
    /**
     * @notice Получить количество минтов пользователя
     */
    function getMintCount(address user) external view returns (uint256) {
        return userMintCount[user];
    }

    // ------------------------
    // Admin
    // ------------------------
    
    function setBasePrice(uint256 _basePrice)
        external
        onlyRole(CONFIG_ROLE)
    {
        require(_basePrice > 0, "Invalid price");
        basePrice = _basePrice;
    }

    function setTreasury(address newTreasury)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(newTreasury != address(0), "Invalid address");
        treasury = newTreasury;
    }

    function setDefaultSharesPerNFT(uint256 shares)
        external
        onlyRole(CONFIG_ROLE)
    {
        require(shares > 0, "Shares must be > 0");
        defaultSharesPerNFT = shares;
    }
    
    function setReferralRewards(address newReferralRewards)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(newReferralRewards != address(0), "Invalid address");
        referralRewards = IReferralRewards(newReferralRewards);
    }

    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _unpause();
    }
}